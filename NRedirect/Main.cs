using System;
using System.IO;
using System.Security.Policy;

namespace NRedirect
{
	public static class Main
	{
		/// <summary>
		/// Entrypoint for a proxy library generated by NDirect.Generator.
		/// </summary>
		public static void Start()
		{
			try
			{
				// For proper redirection, we need to create a new, clean appdomain
				var setupInfo = new AppDomainSetup();

				// However, redirection configs are automatically applied to all new appdomains.
				// Meaning that if the application runs again and tries to search for a library with the same assembly name,
				//   it will launch this pipeline all over again in a loop.

				// So we need to stop this configuration file from being used in the new appdomain, so the original library will be used instead of the proxy.
				// You would EXPECT that these calls will disable this:

				// setupInfo.DisallowBindingRedirects = true;
				// setupInfo.DisallowPublisherPolicy = true;

				// However this doesn't seem to be doing anything at all. The only call that disables these bindings is the one
				//   that points to the application configuration file.
				// Setting it to an empty string, non-existent file or even another config will allow us to stop here.

				// On a similar note, this should achieve the same thing, but doesn't do anything:
				// setupInfo.SetConfigurationBytes(new byte[0]);

				// TODO: Point this to the original .exe config if it exists

				setupInfo.ConfigurationFile = "";

				var domain = AppDomain.CreateDomain("BepInExDomain", new Evidence(), setupInfo);

				// After creating the appdomain, execute the custom assembly in it that we want.
				// AppDomain.ExecuteAssembly executes the entrypoint of an assembly (usually Program.Main).
				// It doesn't necessarily have to be this (i.e. we can point to a .dll with an entrypoint, or we can use a custom entrypoint via reflection)

				domain.ExecuteAssembly("BepInEx.NetLauncher.exe", new string[0]);

				// AppDomain.ExecuteAssembly is a blocking call. If the call returns (in other words, the assembly exits) then we make sure to shut
				//   this AppDomain and parent process, as to respect the wishes of the new AppDomain we created.

				Environment.Exit(0);
			}
			catch (Exception ex)
			{
				File.WriteAllText("ndirect-error.txt", ex.ToString());
				throw;
			}
		}
	}
}